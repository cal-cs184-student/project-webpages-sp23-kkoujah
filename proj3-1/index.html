<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-lTUqgJg2dxbe4D7B5DEIOLRwqQ7C7D8i3X3gnLr00rm74GqoUREvGx3nvtIBwYUOPeqXG-QxW3ZD8BtmPikfA');.lst-kix_vl4519t98dt1-8>li:before{content:"\0025a0  "}.lst-kix_vl4519t98dt1-2>li:before{content:"\0025a0  "}.lst-kix_vl4519t98dt1-0>li:before{content:"\0025cf  "}.lst-kix_vl4519t98dt1-1>li:before{content:"\0025cb  "}.lst-kix_su0qxgo4ma8h-8>li:before{content:"\0025a0  "}.lst-kix_su0qxgo4ma8h-0>li:before{content:"\0025cf  "}.lst-kix_su0qxgo4ma8h-2>li:before{content:"\0025a0  "}.lst-kix_cr1ignug71f7-0>li:before{content:"\0025cf  "}.lst-kix_cr1ignug71f7-2>li:before{content:"\0025a0  "}.lst-kix_su0qxgo4ma8h-1>li:before{content:"\0025cb  "}.lst-kix_su0qxgo4ma8h-5>li:before{content:"\0025a0  "}.lst-kix_cr1ignug71f7-1>li:before{content:"\0025cb  "}.lst-kix_cr1ignug71f7-5>li:before{content:"\0025a0  "}ul.lst-kix_su0qxgo4ma8h-2{list-style-type:none}ul.lst-kix_su0qxgo4ma8h-3{list-style-type:none}ul.lst-kix_su0qxgo4ma8h-4{list-style-type:none}ul.lst-kix_su0qxgo4ma8h-5{list-style-type:none}.lst-kix_su0qxgo4ma8h-6>li:before{content:"\0025cf  "}.lst-kix_cr1ignug71f7-6>li:before{content:"\0025cf  "}ul.lst-kix_su0qxgo4ma8h-0{list-style-type:none}ul.lst-kix_su0qxgo4ma8h-1{list-style-type:none}.lst-kix_su0qxgo4ma8h-7>li:before{content:"\0025cb  "}.lst-kix_cr1ignug71f7-7>li:before{content:"\0025cb  "}.lst-kix_cr1ignug71f7-8>li:before{content:"\0025a0  "}.lst-kix_su0qxgo4ma8h-4>li:before{content:"\0025cb  "}.lst-kix_su0qxgo4ma8h-3>li:before{content:"\0025cf  "}ul.lst-kix_vl4519t98dt1-1{list-style-type:none}ul.lst-kix_vl4519t98dt1-0{list-style-type:none}ul.lst-kix_vl4519t98dt1-3{list-style-type:none}ul.lst-kix_vl4519t98dt1-2{list-style-type:none}ul.lst-kix_cr1ignug71f7-5{list-style-type:none}ul.lst-kix_cr1ignug71f7-4{list-style-type:none}ul.lst-kix_cr1ignug71f7-3{list-style-type:none}ul.lst-kix_cr1ignug71f7-2{list-style-type:none}ul.lst-kix_cr1ignug71f7-1{list-style-type:none}ul.lst-kix_cr1ignug71f7-0{list-style-type:none}.lst-kix_vl4519t98dt1-3>li:before{content:"\0025cf  "}ul.lst-kix_su0qxgo4ma8h-6{list-style-type:none}ul.lst-kix_su0qxgo4ma8h-7{list-style-type:none}ul.lst-kix_cr1ignug71f7-8{list-style-type:none}.lst-kix_vl4519t98dt1-4>li:before{content:"\0025cb  "}.lst-kix_vl4519t98dt1-5>li:before{content:"\0025a0  "}ul.lst-kix_su0qxgo4ma8h-8{list-style-type:none}ul.lst-kix_cr1ignug71f7-7{list-style-type:none}ul.lst-kix_cr1ignug71f7-6{list-style-type:none}.lst-kix_vl4519t98dt1-6>li:before{content:"\0025cf  "}.lst-kix_vl4519t98dt1-7>li:before{content:"\0025cb  "}ul.lst-kix_vl4519t98dt1-8{list-style-type:none}.lst-kix_cr1ignug71f7-4>li:before{content:"\0025cb  "}ul.lst-kix_vl4519t98dt1-5{list-style-type:none}ul.lst-kix_vl4519t98dt1-4{list-style-type:none}ul.lst-kix_vl4519t98dt1-7{list-style-type:none}.lst-kix_cr1ignug71f7-3>li:before{content:"\0025cf  "}ul.lst-kix_vl4519t98dt1-6{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#e06666;font-weight:600;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Montserrat";font-style:normal}.c2{color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Montserrat";font-style:normal}.c1{color:#4078c0;font-weight:900;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Montserrat";font-style:normal}.c4{color:#24292f;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Montserrat";font-style:normal}.c8{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c18{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c3{font-size:12pt;font-family:"Montserrat";color:#333333;font-weight:600}.c6{color:#333333;font-weight:900;font-size:14pt;font-family:"Montserrat"}.c17{color:#d1d5db;font-weight:400;font-size:12pt;font-family:"Roboto"}.c9{font-size:12pt;font-family:"Montserrat";color:#333333;font-weight:400}.c10{font-size:12pt;font-family:"Montserrat";color:#e06666;font-weight:600}.c15{color:#333333;font-weight:900;font-size:16pt;font-family:"Montserrat"}.c7{font-size:14pt;font-family:"Montserrat";color:#4078c0;font-weight:900}.c11{color:#4078c0;font-weight:900;font-size:12pt;font-family:"Montserrat"}.c5{text-decoration:none;vertical-align:baseline;font-style:normal}.c13{color:inherit;text-decoration:inherit}.c16{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{height:11pt}.c12{background-color:#ffffff}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c12 c16 doc-content"><p class="c18"><span class="c5 c15">CS184 Assignment 3-1</span></p><p class="c8"><span class="c5 c6">Overview</span></p><p class="c8"><span class="c2">In this project, we implement some core routines involved in rendering. First, we will implement ray intersection and scene intersection to generate the rays, and determine whether the rays we shoot out intersect the objects, particularly for sphere and triangle meshes. To speed up the rendering process, specifically for images with complex geometries, we implement the BVH acceleration structures. We start by creating bounding boxes to reduce the amount of computation we have to do and ignore areas where we know that the ray won&rsquo;t intersect. After this, we focus on lighting in multiple ways. First, we do direct illumination by implementing algorithms for uniform hemisphere sampling and importance sampling. Then, we integrate indirect illumination to get the full picture. Finally, we implement adaptive sampling to reduce noise in the rendered image. This project was an amazing learning experience, allowing us to gain hands-on experience with the different aspects of rendering, and the processes all being called to ultimately produce a rendered, high resolution, lit up image. It also gave us insight into how the different factors like the amount of light rays, the max ray depth, and samples-per-pixel affect the amount of time it takes to render an image and how it affects the resolution, lighting, and noise in the image.</span></p><p class="c8"><span class="c6">Part 1: </span><span class="c7"><a class="c13" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-1&amp;sa=D&amp;source=editors&amp;ust=1679034377932950&amp;usg=AOvVaw2dbqIy3wU9bHPGMx6uT7h_">Ray Generation and Scene Intersection</a></span></p><p class="c8"><span class="c3 c5">Task 1: Generating Camera Rays</span></p><p class="c8"><span class="c2">In this task, we use the generate_ray function to map from the normalized image coordinates and outputs a generated Ray in the world space. To do this, we change the coordinates from the center to be in the origin, and used the provided coordinates to map from the 2D space for the 3D space. To map the coordinate to the 3D world space, we multiply the x and y coordinates by &nbsp;2*tan(hFov/2) and &nbsp;2*tan(vFov/2). We then multiply the direction vector by the c2w matrix and normalize. Finally, we use these values to generate the ray. The main objective of generating the ray involves converting the standardized coordinates to the 3D world space, for which we use the o2w matrix.</span></p><p class="c8"><span class="c3 c5">Task 2: Generating Camera Pixels</span></p><p class="c8"><span class="c2">In this task, we take the given pixel coordinates and update the sampleBuffer at those coordinates with the integral of the radiance over this pixel. We get the integral value by averaging over ns_aa number of samples to generate the rays. We loop ns_aa number of times, each time we generate a ray and trace that ray to get the global illumination at that point, and eventually using this to get the average Vector3D. </span></p><p class="c8"><span class="c2">Initially, we were having trouble with this part, then we realized that the coordinates needed to be scaled to the sampleBuffer width and height. After normalizing to ensure the values lie within [0, 1], we were able to complete the task.</span></p><p class="c8"><span class="c3 c5">Task 3: Ray-Triangle Intersection</span></p><p class="c8"><span class="c2">For this task, we implement has_intersect() and intersect() which test to see whether an input ray intersects with a triangle. To do this, we use the Moller Trumbore algorithm. Using the vertices of the triangle and the vertex normals at those points, we plug these values into the algorithm which yields us t, b1, and b2. Utilizing barycentric coordinates, we get the b3 value and return whether the 0 &lt;= b1, b2, b3 &lt;= 1 and if the calculated t value lies between min_t and max_t of the ray, telling us whether there is an intersection or not. In the next function, we do the same thing but we also store these values.</span></p><p class="c8"><span class="c3 c5">Task 4: Ray-Sphere Intersection</span></p><p class="c8"><span class="c2">Similar to task 3, here we do the same thing but instead check whether the input ray intersects with a sphere. We first calculate the discriminant, then ensure that the discriminant is &gt;= 0, signifying that the t values exist. We then take the smaller of the t values yielded by the quadratic equation, and return if these values lie between min_t and max_t which tells us whether the ray intersects with the sphere or not. In the intersect() function, we do the same thing but store the values with the smaller of the t&rsquo;s, to ensure that we take the first time that the ray intersects with the sphere.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.50px; height: 154.45px;"><img alt="" src="images/image14.png" style="width: 205.50px; height: 154.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 196.50px; height: 152.04px;"><img alt="" src="images/image7.png" style="width: 196.50px; height: 152.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 197.50px; height: 152.71px;"><img alt="" src="images/image44.png" style="width: 197.50px; height: 152.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c14"><span class="c2"></span></p><p class="c8"><span class="c6">Part 2: </span><span class="c7"><a class="c13" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-2&amp;sa=D&amp;source=editors&amp;ust=1679034377935403&amp;usg=AOvVaw2WPpodozwcuRqPvboZqSJi">Bounding Volume Hierarchy</a></span></p><p class="c8"><span class="c3 c5">Task 1: Constructing the BVH</span></p><p class="c8"><span class="c9">In this problem, we set up a bounding volume hierarchy to speed up the rendering process to speed up our </span><span class="c9">pathtracer</span><span class="c2">. To use BVH acceleration, we were first tasked with setting up a BVH which is done in a similar fashion to a binary tree. This automatically omits collections of primitives that are guaranteed to not intersect the ray. To do this, we first compute the bounding box and initialize a BVH node in that bbox. Then we check to see if that node is a leaf based on whether or not it is &lt;= max_leaf_size. Next, our job is to split along the axis that will provide us with the most benefit by reducing our computation. To divide the primitives into a left and right set to construct our BVH tree, we need to partition the points on a split point. </span></p><p class="c8"><span class="c2">Originally we were using the max &nbsp;of the x, y, z extent of the bounding box, but this did not account for the case that all of the primitives lie on the same side of the split point. Moreover, if multiple axes had the same extent that was the maximum of the x, y, z then it also wouldn&rsquo;t work. After our failure, we then started splitting along the axis with the max difference in centroid positions. &nbsp;By comparing the extent of each of the axes and keeping track of the axis that provided us with the largest extent difference, we then partition the set, with the points whose centroid on the given axis are less than the split point going in the left set, and those greater than the split point going to the right.</span></p><p class="c8"><span class="c2">We then recursively call the construct_bvh() function on each of the child nodes as long as they are not empty, and ultimately we return once we&rsquo;ve traversed the entire tree to reach the leaf nodes.</span></p><p class="c8"><span class="c3 c5">Task 2: Intersecting the Bounding Box </span></p><p class="c8"><span class="c2">In this task, we need to compute the time frame [t0, t1] during which the ray lies within the bounding box. To do this, we just used the ray and axis-aligned plane intersection equations as shown in lecture. We used these formulas for both the x, y, and z axes and then took the minimum and maximum to see when the ray entered and exited the bounding box. </span></p><p class="c8"><span class="c3">Task 3: Intersecting the BVH<br></span><span class="c2">Similar to what was done in Part 1, we use the functions has_intersection() and intersect to determine whether there is an intersection between any of the primitives and the input ray, and storing that data in the Intersect data structure. To accomplish this, we filled out has_intersection() to just tell us whether there was any intersection at all or not, and use this to determine whether we need to perform the computation in intersect(). If there is an intersection, we recursively call this function until we reach the leaf nodes, at which point we compare the new time of intersection with what has already been stored. If the new time is smaller, then we update our ray&rsquo;s max_t and choose this new, nearer intersection. </span></p><p class="c8"><span class="c2">To speed up the computation, we first check to see if the ray intersects with the associated node&rsquo;s bounding box, and only traverse the BVH tree if it does. We traverse down to the leaf nodes, which are the only nodes that can intersect with the primitives.</span></p><p class="c8"><span class="c2">Each step of BVH, showing the bounding box and splitting along the axes with the highest centroid difference. </span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.91px; height: 196.50px;"><img alt="" src="images/image11.png" style="width: 244.91px; height: 196.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 233.17px; height: 196.50px;"><img alt="" src="images/image1.png" style="width: 246.33px; height: 196.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.50px; height: 199.61px;"><img alt="" src="images/image18.png" style="width: 249.59px; height: 199.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.66px; height: 199.56px;"><img alt="" src="images/image41.png" style="width: 249.79px; height: 199.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 241.50px; height: 194.33px;"><img alt="" src="images/image13.png" style="width: 241.50px; height: 194.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 242.50px; height: 194.62px;"><img alt="" src="images/image3.png" style="width: 242.50px; height: 194.62px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3 c5">Rendered with BVH acceleration structure</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 200.29px; height: 149.50px;"><img alt="" src="images/image5.png" style="width: 200.29px; height: 149.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 200.50px; height: 150.38px;"><img alt="" src="images/image32.png" style="width: 200.50px; height: 150.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 201.50px; height: 150.65px;"><img alt="" src="images/image46.png" style="width: 201.50px; height: 150.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3">Naive - Cow.dae: </span><span class="c0">4.2428 sec</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 157.33px;"><img alt="" src="images/image31.png" style="width: 624.00px; height: 157.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3">BVH Acceleration - Cow.dae: </span><span class="c10">0.0241 sec</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 153.33px;"><img alt="" src="images/image38.png" style="width: 624.00px; height: 153.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3">Naive - CBlucy</span><span class="c3">.dae</span><span class="c3">: </span><span class="c0">177.6987 sec</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 154.67px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 154.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3">BVH Acceleration - CBlucy</span><span class="c3">.dae</span><span class="c3">: </span><span class="c10">0.0256 sec</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 153.33px;"><img alt="" src="images/image40.png" style="width: 624.00px; height: 153.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">As can be seen from the screenshots above, the performance difference from the case with BVH acceleration and the naive implementation that we were previously using is significantly different. In the case of Cow.dae, we achieved a speedup of almost 176 times faster, and 7k times faster in the larger, more complex CBlucy.dae. Similar to what we talked about in class, and what can be seen from the first screenshots in this section, reducing the area to where we know the primitives lie and omitting where we know the ray is not going to intersect, we can render the overall image much much faster. Particularly when we rendered CBLucy.dae and some of the other larger files with more complex geometries, it can be seen how effective BVH acceleration actually is. </span></p><p class="c8"><span class="c6">Part 3: </span><span class="c7"><a class="c13" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-3&amp;sa=D&amp;source=editors&amp;ust=1679034377940987&amp;usg=AOvVaw3nbca-IUjXLWIHaXKDojZ3">Direct Illumination</a></span></p><p class="c8"><span class="c3">Task 1: Diffuse BSDF</span></p><p class="c8"><span class="c9">The diffuse BSDF is f(wo, wi) = albedo (reflectance) / pi</span></p><p class="c8"><span class="c3 c5">Task 2: Zero-Bounce Illumination</span></p><p class="c8"><span class="c9">We use the get_emission function of the BSDF to show zero-bounce illumination.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 214.30px; height: 160.50px;"><img alt="" src="images/image29.png" style="width: 214.30px; height: 160.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3 c5">Task 3: Direct Lighting with Uniform Hemisphere Sampling</span></p><p class="c8"><span class="c2">Here, we implement the estimate_direct_lighting_hemisphere function which samples direct lighting over a uniformly sampled hemisphere. We utilize the rendering equation around the point of interest and use the Monte Carlo estimator provided in the slides to uniformly sample incoming ray directions in the hemisphere with direct illumination. After we&rsquo;ve calculated the incoming light (a rough approx of it), we can use the rendering equation to calculate the outgoing light.</span></p><p class="c8"><span class="c9">In our implementation, we use the hemisphereSampler to get the object vector representation uniformly sampled on the hemisphere, generate a sample ray in the direction of the hemisphere, and see if it intersects the ray. If so, then we aggregate the resulting emission, multiply by direction of the sample and 2*PI to get the final value. Finally, we normalize by the number of samples and since the probability of the sample are the same, we don&rsquo;t need to multiply by the probability of taking each sample. We then update one_bounce_radiance to return this function to see the global illumination, as shown below.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 270.50px; height: 203.34px;"><img alt="" src="images/image19.png" style="width: 270.50px; height: 203.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 267.50px; height: 201.09px;"><img alt="" src="images/image28.png" style="width: 267.50px; height: 201.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 270.50px; height: 203.34px;"><img alt="" src="images/image27.png" style="width: 270.50px; height: 203.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c3">Task 4: Direct Lighting by Importance Sampling Lights</span></p><p class="c8"><span class="c9">&nbsp;</span><span class="c2">For this task, we filled in the estimate_direct_lighting_importance which samples all the lights directly. We generate a ray, cast it in the direction of the point of interest and if there is no object between the light cast and the point, then we know that the light source casts light onto the hit point. This function is similar to the last function, but we weight the samples based on the underlying pdf which represents the probability of taking a particular sample. Finally, we normalize the light out. </span></p><p class="c8"><span class="c2">Various images rendered with importance sampling.</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 260.50px; height: 196.45px;"><img alt="" src="images/image35.png" style="width: 260.50px; height: 196.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 259.50px; height: 194.63px;"><img alt="" src="images/image45.png" style="width: 259.50px; height: 194.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 267.50px; height: 193.71px;"><img alt="" src="images/image43.png" style="width: 267.50px; height: 270.13px; margin-left: 0.00px; margin-top: -60.13px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 257.99px; height: 194.44px;"><img alt="" src="images/image6.png" style="width: 257.99px; height: 194.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">To compare noise levels in soft shadows, we render with 1, 4, 16, and 64 light rays and with 1 sample per pixel. These images are shown below. As we increase the light rays, we can see that as we increase the number of light rays, this leads to less noise in the overall image, especially in the soft shadows below the spheres. The noise in the 1 and 4 light rays case is significant, but decreases significantly as we increase to 64.</span></p><p class="c8"><span class="c9">1:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 246.33px; height: 186.28px;"><img alt="" src="images/image36.png" style="width: 246.33px; height: 186.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c9">4:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 247.72px; height: 186.82px;"><img alt="" src="images/image30.png" style="width: 247.72px; height: 186.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c9">16:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 244.59px; height: 183.98px;"><img alt="" src="images/image42.png" style="width: 244.59px; height: 183.98px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c9">64:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 249.20px; height: 187.44px;"><img alt="" src="images/image37.png" style="width: 249.20px; height: 187.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c9">Ultimately, the images that were produced from the uniform sampling had a significant amount of grain. Particularly in the case of CBbunny, we can see the grain and noise on the object itself and on the wall behind. From the images, we can see that the importance sampling is rendered significantly more accurately and efficiently. Intuitively, this is because the light sampling, relative to the uniform sampling, focuses on the light sources in the scene which leads to less noise and faster convergence. The uniform sampling is more natural, and distributes the light more evenly through the image, but in the important sampling it is significantly more smooth because of the focus on the light source on the object.</span></p><p class="c8"><span class="c6">Part 4: </span><span class="c7"><a class="c13" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-4&amp;sa=D&amp;source=editors&amp;ust=1679034377945002&amp;usg=AOvVaw3xa00yulRiUrrUMt4uEls3">Global Illumination</a></span></p><p class="c8"><span class="c3 c5">Task 1: Sampling with Diffuse BSDF </span></p><p class="c8"><span class="c9">In this task, we implement the sample_f function, which takes in wi, wo, and the pdf. We simply sample for a value at wi, and return the evaluation of the BSDF by calling the f() function that we implemented earlier.</span></p><p class="c8"><span class="c3 c5">Task 2: Global Illumination</span></p><p class="c8"><span class="c2">In this task, we aim to render images with full global illumination. To do this, we implement at_least_one_bounce_radiance which first calls the one_bounce_radiance function recursively to estimate the higher bounces until we&rsquo;ve reached the max_ray_depth. We implement the base case by initializing the depth of the rays produced to max_ray_depth, and decrement this value upon each recursive call, terminating when we reach 0. Overall, this function takes one random sample of a direction based on the BSDF of the hit point, traces a ray in that direction, sees if it intersects, and calls itself based on some probability, which in our case is 0.65.</span></p><p class="c8"><span class="c2">To stop infinite recursion, we use the Russian Roulette technique which provides us an unbiased method of random termination. In the case that the ray doesn&rsquo;t intersect the scene, we don&rsquo;t recurse but if it does then we continue with a probability of 0.65, based on the recommended termination probability between 0.3 and 0.4.</span></p><p class="c8"><span class="c2">In the function, if the ray intersects, we make sure to normalize by the continuation probability and include the multiplicative factors as well as the probability of taking the sample.</span></p><p class="c8"><span class="c9">Only direct illumination with 1024 samples per pixel:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.50px; height: 223.88px;"><img alt="" src="images/image33.png" style="width: 298.50px; height: 223.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">Only indirect illumination with 1024 samples per pixel:</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.50px; height: 221.25px;"><img alt="" src="images/image20.png" style="width: 295.50px; height: 221.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">&nbsp; &nbsp; &nbsp; M=0, 1024 samples per pixel &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M=1, &nbsp;1024 samples per pixel</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 291.50px; height: 221.30px;"><img alt="" src="images/image22.png" style="width: 291.50px; height: 221.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 293.43px; height: 219.30px;"><img alt="" src="images/image4.png" style="width: 293.43px; height: 219.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">&nbsp; &nbsp; &nbsp;M=2, &nbsp;1024 samples per pixel &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;M=3, &nbsp;1024 samples per pixel &nbsp; &nbsp;</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.50px; height: 217.88px;"><img alt="" src="images/image10.png" style="width: 290.50px; height: 217.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.33px; height: 220.67px;"><img alt="" src="images/image8.png" style="width: 296.33px; height: 220.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M=100, &nbsp;1024 samples per pixel</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 590.50px; height: 441.81px;"><img alt="" src="images/image17.png" style="width: 590.50px; height: 441.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">4 light rays, sample-per-pixel rate is 1 &nbsp; &nbsp; &nbsp; 4 light rays, sample-per-pixel rate is 2</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.12px; height: 219.93px;"><img alt="" src="images/image16.png" style="width: 290.12px; height: 219.93px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 295.50px; height: 221.33px;"><img alt="" src="images/image21.png" style="width: 295.50px; height: 221.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">4 light rays, sample-per-pixel rate is 4 &nbsp; 4 light rays, sample-per-pixel rate is 8</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 279.50px; height: 209.63px;"><img alt="" src="images/image15.png" style="width: 279.50px; height: 209.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 284.50px; height: 213.38px;"><img alt="" src="images/image39.png" style="width: 284.50px; height: 213.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">4 light rays, sample-per-pixel rate is 16 4 light rays, sample-per-pixel rate is 64</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 287.87px; height: 214.87px;"><img alt="" src="images/image24.png" style="width: 287.87px; height: 214.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 289.50px; height: 216.29px;"><img alt="" src="images/image34.png" style="width: 289.50px; height: 216.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c14"><span class="c3 c5"></span></p><p class="c8"><span class="c2">4 light rays, sample-per-pixel rate is 128 &nbsp; &nbsp; &nbsp; </span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 527.50px; height: 394.06px;"><img alt="" src="images/image2.png" style="width: 527.50px; height: 394.06px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c14"><span class="c3 c5"></span></p><p class="c8 c14"><span class="c3 c5"></span></p><p class="c8"><span class="c6">Part 5: </span><span class="c7"><a class="c13" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp23/docs/proj3-1-part-5&amp;sa=D&amp;source=editors&amp;ust=1679034377949204&amp;usg=AOvVaw3C7L-FnGL8VTcSK5pTiOGq">Adaptive Sampling</a></span></p><p class="c8 c12"><span class="c4">Up until this point in the project, we have been sampling at the same rate for each pixel. For some pixels this will allow them to converge to a single color value much quicker, but for other pixels it will take a lot longer. That is why we implement adaptive sampling, which is an algorithm that focuses on the pixels that haven&rsquo;t been converged and we stop computation with the ones that have been converged. To implement the algorithm I would check every samplesPerBatch to see if my &lsquo;I&rsquo; value is less than or equal to the cvoff value. &lsquo;I&rsquo; represents the convergence of a pixel and it was the formula that was on the spec and the slides. Then I would check to see if it was below or equal the cutoff value which then was terminated if it hit the condition. </span></p><p class="c8 c12"><span class="c4">The images below were rendered with adaptive sampling at 2048 sample per pixel upper-bound, a ray depth of 5 (for global illumination), and a sampling batch size of 64 rays. Regions in the scene with greater surface complexity that have more detail and texture, in this case, the bunny, require more samples per pixel due to the fact that the variance of the samples in these regions are higher which take a longer time to converge. So adaptive sampling focuses more on those regions because they have much more variance. </span></p><p class="c8 c12"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Final Rendered Image&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sample Rate</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.38px; height: 240.24px;"><img alt="" src="images/image25.png" style="width: 322.38px; height: 240.24px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.00px; height: 242.88px;"><img alt="" src="images/image12.png" style="width: 322.00px; height: 242.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c14 c12"><span class="c4"></span></p><p class="c8 c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.00px; height: 242.59px;"><img alt="" src="images/image26.png" style="width: 322.00px; height: 242.59px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.00px; height: 245.63px;"><img alt="" src="images/image9.png" style="width: 322.00px; height: 245.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>